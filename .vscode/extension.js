"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(extension_exports);
var vscode2 = __toESM(require("vscode"));
var path = __toESM(require("path"));

// src/graphTypes.ts
var vscode = __toESM(require("vscode"));
var CodeGraph = class {
  nodes = /* @__PURE__ */ new Map();
  edges = /* @__PURE__ */ new Map();
  addNode(node) {
    if (!this.nodes.has(node.id)) {
      this.nodes.set(node.id, node);
    }
  }
  /**
   * Represents the data needed to create a new edge, excluding the 'id'
   * which is generated by the CodeGraph.
   */
  addEdge(edgePayload) {
    const edgeId = `${edgePayload.sourceId}_${edgePayload.type}_${edgePayload.targetId}`;
    if (!this.edges.has(edgeId)) {
      this.edges.set(edgeId, { ...edgePayload, id: edgeId });
    }
  }
  // You can add more methods here for querying the graph
  getNode(id) {
    return this.nodes.get(id);
  }
  getEdges() {
    return Array.from(this.edges.values());
  }
  getNodes() {
    return Array.from(this.nodes.values());
  }
  clear() {
    this.nodes.clear();
    this.edges.clear();
  }
};
function generateNodeId(uri, symbol) {
  return `${uri.toString()}#${symbol.kind}_${symbol.name}`;
}
function toNodeKind(symbolKind) {
  if (symbolKind >= vscode.SymbolKind.File && symbolKind <= vscode.SymbolKind.TypeParameter) {
    return symbolKind;
  }
  return 1001 /* Reference */;
}

// src/extension.ts
var currentGraph = new CodeGraph();
var OPENAI_CHAT_API_KEY = "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";
var OPENAI_EMBEDDING_API_KEY = "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";
var cachedSchemaChunks = [];
var isSchemaLoading = false;
var sqlFilesBaseUri;
function activate(context) {
  console.log('Congratulations, your extension "SaralFlow" is now active!');
  loadSchemaContext();
  const sqlWatcher = vscode2.workspace.createFileSystemWatcher("**/*.sql");
  let reloadTimeout;
  const debouncedReload = () => {
    if (reloadTimeout) {
      clearTimeout(reloadTimeout);
    }
    reloadTimeout = setTimeout(() => {
      vscode2.window.showInformationMessage("SQL files changed. Reloading schema context...");
      loadSchemaContext();
    }, 2e3);
  };
  sqlWatcher.onDidChange(debouncedReload);
  sqlWatcher.onDidCreate(debouncedReload);
  sqlWatcher.onDidDelete(debouncedReload);
  context.subscriptions.push(sqlWatcher);
  const disposableHelloWorld = vscode2.commands.registerCommand("SaralFlow.helloWorld", () => {
    vscode2.window.showInformationMessage("Hello World from SaralFlow!");
  });
  context.subscriptions.push(disposableHelloWorld);
  let disposable = vscode2.commands.registerCommand("SaralFlow.showGraph", async () => {
    vscode2.window.showInformationMessage("Generating Code Semantic Graph...");
    currentGraph.clear();
    const activeEditor = vscode2.window.activeTextEditor;
    if (!activeEditor) {
      vscode2.window.showInformationMessage("No active text editor found.");
      return;
    }
    const document = activeEditor.document;
    if (document.uri.scheme !== "file") {
      vscode2.window.showInformationMessage("SaralFlow: Only file-based documents can be analyzed.");
      return;
    }
    try {
      const fileNodeId = generateNodeId(document.uri, { name: document.fileName, kind: vscode2.SymbolKind.File });
      currentGraph.addNode({
        id: fileNodeId,
        label: document.fileName,
        kind: 0 /* File */,
        uri: document.uri,
        range: new vscode2.Range(0, 0, 0, 0)
      });
      const symbols = await vscode2.commands.executeCommand(
        "vscode.executeDocumentSymbolProvider",
        document.uri
      );
      if (symbols && symbols.length > 0) {
        vscode2.window.showInformationMessage(`Found ${symbols.length} symbols in ${document.fileName}.`);
        console.log("Document Symbols:", symbols);
        await processDocumentSymbols(document, symbols, currentGraph, fileNodeId);
        for (const node of currentGraph.getNodes()) {
          if (node.uri.toString() !== document.uri.toString()) {
            continue;
          }
          if (node.kind === 11 /* Function */ || node.kind === 5 /* Method */ || node.kind === 8 /* Constructor */) {
            await fetchAndProcessCallHierarchy(document, node, currentGraph);
          }
        }
        console.log("--- Final Graph Data ---");
        console.log("Nodes:", currentGraph.getNodes());
        console.log("Edges:", currentGraph.getEdges());
        vscode2.window.showInformationMessage(`SaralFlow: Graph built with ${currentGraph.nodes.size} nodes and ${currentGraph.edges.size} edges.`);
      } else {
        vscode2.window.showInformationMessage(`No symbols found in ${document.fileName}. Graph will only contain the file node.`);
      }
    } catch (error) {
      console.error("Error building semantic graph:", error);
      vscode2.window.showErrorMessage(`SaralFlow: Failed to build semantic graph. Error: ${error instanceof Error ? error.message : String(error)}. Ensure a language extension is active for this file type.`);
    }
  });
  context.subscriptions.push(disposable);
  const memGraphStatusBarItem = vscode2.window.createStatusBarItem(vscode2.StatusBarAlignment.Right, 90);
  memGraphStatusBarItem.text = `$(robot) SaralGraph`;
  memGraphStatusBarItem.tooltip = "Show Graph";
  memGraphStatusBarItem.command = "SaralFlow.showGraph";
  memGraphStatusBarItem.show();
  context.subscriptions.push(memGraphStatusBarItem);
  const disposableSqlGenerator = vscode2.commands.registerCommand("SaralFlow.openSqlGenerator", () => {
    const panel = vscode2.window.createWebviewPanel(
      "saralFlowSqlGenerator",
      // Unique ID for the panel
      "SaralFlow SQL Generator",
      // Title displayed in the panel header
      vscode2.ViewColumn.One,
      // Editor column to show the new webview panel in.
      {
        enableScripts: true
        // Enable JavaScript in the webview
      }
    );
    panel.webview.html = getWebviewContent(panel.webview, context.extensionUri);
    panel.webview.onDidReceiveMessage(
      async (message) => {
        switch (message.command) {
          case "generateSql":
            const scenario = message.text;
            let proposedSql = "";
            if (isSchemaLoading) {
              proposedSql = "Schema context is currently loading. Please wait a moment and try again.";
              panel.webview.postMessage({ command: "displaySql", text: proposedSql });
              vscode2.window.showWarningMessage("SQL schema context is still loading. Please wait.");
              return;
            }
            let relevantSqlContext = "";
            if (cachedSchemaChunks.length > 0) {
              panel.webview.postMessage({ command: "displaySql", text: "Searching for relevant schema..." });
              const scenarioEmbedding = await getEmbedding(scenario, OPENAI_EMBEDDING_API_KEY);
              if (scenarioEmbedding) {
                const topN = 5;
                const rankedChunks = cachedSchemaChunks.map((chunk) => ({
                  text: chunk.text,
                  similarity: cosineSimilarity(scenarioEmbedding, chunk.embedding)
                })).sort((a, b) => b.similarity - a.similarity).slice(0, topN);
                relevantSqlContext = rankedChunks.map((chunk) => `-- Similarity: ${chunk.similarity.toFixed(4)}
${chunk.text}`).join("\n-- --- Relevant Schema Chunk ---\n");
                vscode2.window.showInformationMessage(`Found ${rankedChunks.length} relevant schema chunks.`);
              } else {
                vscode2.window.showErrorMessage("Failed to generate embedding for scenario.");
              }
            } else {
              vscode2.window.showInformationMessage("No SQL files found or processed for context. Please ensure .sql files are in your workspace.");
            }
            const prompt = `You are an expert SQL Server database developer.
                                        Generate SQL Server DDL (Data Definition Language) statements.
                                        For new tables, provide 'CREATE TABLE' statements.
                                        For changes to existing tables (e.g., adding a column, modifying a column), provide the full 'CREATE TABLE' statement reflecting the new desired state. Do NOT use ALTER TABLE for these types of changes, instead provide the complete CREATE TABLE statement.
                                        For new stored procedures, views, or functions, provide 'CREATE PROCEDURE', 'CREATE VIEW', or 'CREATE FUNCTION' statements.
                                        For modifications to existing stored procedures, views, or functions, provide 'CREATE OR ALTER PROCEDURE', 'CREATE OR ALTER VIEW', or 'CREATE OR ALTER FUNCTION' statements to ensure idempotency.
                                        For dropping objects, provide 'DROP TABLE', 'DROP PROCEDURE', 'DROP VIEW', or 'DROP FUNCTION' statements.
                                        IMPORTANT: Each distinct DDL statement (CREATE, ALTER, DROP) MUST be separated by a 'GO' command on its own line. For example:
                                        CREATE TABLE MyNewTable (Id INT PRIMARY KEY);
                                        GO
                                        CREATE OR ALTER PROCEDURE MySproc AS BEGIN SELECT 1; END;
                                        GO
                                        ALTER TABLE ExistingTable ADD NewColumn INT; -- Note: LLM should avoid ALTER TABLE for full table changes as per above.
                                        GO
                                        Focus on SQL Server syntax. Consider the existing database schema provided below.
                                        Provide only the SQL code, no conversational text or explanations. If no changes are needed, state "No changes needed."

                                        --- Relevant Existing SQL Server Schema Context ---
                                        ${relevantSqlContext || "No relevant existing SQL schema context found."}
                                        --- End of Schema Context ---

                                        Scenario: "${scenario}"

                                        SQL:`;
            try {
              panel.webview.postMessage({ command: "displaySql", text: "Sending to LLM for generation..." });
              const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "Authorization": `Bearer ${OPENAI_CHAT_API_KEY}`
                },
                body: JSON.stringify({
                  model: "gpt-3.5-turbo",
                  // Consider 'gpt-4' for better context handling
                  messages: [{ role: "user", content: prompt }],
                  temperature: 0.7,
                  max_tokens: 1e3
                })
              });
              if (!response.ok) {
                const errorData = await response.json();
                console.error("OpenAI API error:", errorData);
                throw new Error(`OpenAI API error: ${response.status} - ${errorData.error ? errorData.error.message : response.statusText}`);
              }
              const data = await response.json();
              proposedSql = data.choices[0].message.content.trim();
            } catch (error) {
              console.error("Error generating SQL:", error);
              proposedSql = `Error generating SQL: ${error.message || "An unknown error occurred."}

Please check your API key, internet connection, and ensure your prompt/context are not too large for the LLM.`;
              vscode2.window.showErrorMessage(`Failed to generate SQL: ${error.message || "Check Debug Console."}`);
            }
            panel.webview.postMessage({ command: "displaySql", text: proposedSql });
            return;
          case "acceptChange":
            const sqlToApply = message.text;
            if (sqlToApply.trim()) {
              vscode2.window.showInformationMessage(
                "Are you sure you want to apply these SQL changes to your project?",
                "Yes",
                "No"
              ).then(async (selection) => {
                if (selection === "Yes") {
                  panel.webview.postMessage({ command: "displaySql", text: "Applying changes..." });
                  await applySqlChanges(sqlToApply);
                  panel.webview.postMessage({ command: "displaySql", text: "Changes applied. Please review your files." });
                } else {
                  panel.webview.postMessage({ command: "displaySql", text: "Changes not applied." });
                }
              });
            } else {
              vscode2.window.showWarningMessage("No SQL code to apply.");
            }
            return;
        }
      },
      void 0,
      context.subscriptions
    );
  });
  context.subscriptions.push(disposableSqlGenerator);
  const sqlStatusBarItem = vscode2.window.createStatusBarItem(vscode2.StatusBarAlignment.Right, 90);
  sqlStatusBarItem.text = `$(flame) SaralFlow`;
  sqlStatusBarItem.tooltip = "Open SaralFlow Code Generator";
  sqlStatusBarItem.command = "SaralFlow.openSqlGenerator";
  sqlStatusBarItem.show();
  context.subscriptions.push(sqlStatusBarItem);
}
async function getEmbedding(text, apiKey) {
  try {
    const response = await fetch("https://api.openai.com/v1/embeddings", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: "text-embedding-ada-002",
        // Recommended embedding model
        input: text
      })
    });
    if (!response.ok) {
      const errorData = await response.json();
      console.error("OpenAI Embedding API error:", errorData);
      throw new Error(`Embedding API error: ${response.status} - ${errorData.error ? errorData.error.message : response.statusText}`);
    }
    const data = await response.json();
    return data.data[0].embedding;
  } catch (error) {
    console.error("Error getting embedding:", error);
    return null;
  }
}
async function loadSchemaContext() {
  if (isSchemaLoading) {
    console.log("Schema loading is already in progress. Skipping new load request.");
    return;
  }
  isSchemaLoading = true;
  cachedSchemaChunks = [];
  sqlFilesBaseUri = void 0;
  try {
    const dboFolders = await vscode2.workspace.findFiles("**/dbo", "**/node_modules/**", 1);
    if (dboFolders.length > 0) {
      sqlFilesBaseUri = dboFolders[0];
      vscode2.window.showInformationMessage(`Found SQL base folder: ${sqlFilesBaseUri.fsPath}`);
    } else if (vscode2.workspace.workspaceFolders && vscode2.workspace.workspaceFolders.length > 0) {
      sqlFilesBaseUri = vscode2.workspace.workspaceFolders[0].uri;
      vscode2.window.showWarningMessage('Could not find a "dbo" folder. Assuming SQL files are relative to workspace root.');
    } else {
      vscode2.window.showErrorMessage("No workspace folder open. Cannot load SQL context.");
      isSchemaLoading = false;
      return;
    }
    const sqlFiles = await vscode2.workspace.findFiles("**/*.sql", "**/node_modules/**", 100);
    if (sqlFiles.length === 0) {
      vscode2.window.showInformationMessage("No .sql files found in the workspace for context. The generator will proceed without schema context.");
      isSchemaLoading = false;
      return;
    }
    const relevantSqlFiles = sqlFiles.filter((fileUri) => fileUri.fsPath.startsWith(sqlFilesBaseUri.fsPath));
    if (relevantSqlFiles.length === 0) {
      vscode2.window.showInformationMessage("No relevant .sql files found under the determined SQL base folder.");
      isSchemaLoading = false;
      return;
    }
    vscode2.window.showInformationMessage(`Found ${relevantSqlFiles.length} relevant .sql files for context. Generating embeddings... This might take a moment.`);
    let processedChunks = [];
    for (const fileUri of relevantSqlFiles) {
      try {
        const fileContent = await vscode2.workspace.fs.readFile(fileUri);
        const sqlText = new TextDecoder().decode(fileContent);
        const chunks = sqlText.split(/(CREATE TABLE|ALTER TABLE|CREATE PROCEDURE|ALTER PROCEDURE|INSERT INTO|UPDATE|DELETE FROM)\s/gi).filter((chunk) => chunk.trim().length > 0).map((chunk, index, arr) => {
          if (index > 0 && arr[index - 1].match(/^(CREATE TABLE|ALTER TABLE|CREATE PROCEDURE|ALTER PROCEDURE|INSERT INTO|UPDATE|DELETE FROM)$/i)) {
            return arr[index - 1] + " " + chunk;
          }
          return chunk;
        }).filter((chunk) => chunk.trim().length > 0);
        for (const chunk of chunks) {
          const embedding = await getEmbedding(chunk, OPENAI_EMBEDDING_API_KEY);
          if (embedding) {
            processedChunks.push({ text: chunk, embedding });
          }
        }
      } catch (readError) {
        console.warn(`Could not process file ${fileUri.fsPath}: ${readError.message}`);
      }
    }
    cachedSchemaChunks = processedChunks;
    vscode2.window.showInformationMessage(`Generated embeddings for ${cachedSchemaChunks.length} schema chunks. Context ready.`);
  } catch (error) {
    console.error("Error finding, reading, or embedding SQL files:", error);
    vscode2.window.showErrorMessage(`Error processing SQL project context: ${error.message}`);
    cachedSchemaChunks = [];
    sqlFilesBaseUri = void 0;
  } finally {
    isSchemaLoading = false;
  }
}
function cosineSimilarity(vec1, vec2) {
  if (vec1.length !== vec2.length) {
    console.error("Vectors must be of the same length for cosine similarity.");
    return 0;
  }
  let dotProduct = 0;
  let magnitude1 = 0;
  let magnitude2 = 0;
  for (let i = 0; i < vec1.length; i++) {
    dotProduct += vec1[i] * vec2[i];
    magnitude1 += vec1[i] * vec1[i];
    magnitude2 += vec2[i] * vec2[i];
  }
  magnitude1 = Math.sqrt(magnitude1);
  magnitude2 = Math.sqrt(magnitude2);
  if (magnitude1 === 0 || magnitude2 === 0) {
    return 0;
  }
  return dotProduct / (magnitude1 * magnitude2);
}
async function applySqlChanges(sqlCode) {
  if (!sqlFilesBaseUri) {
    vscode2.window.showErrorMessage('SQL base folder not identified. Please ensure your project has a "dbo" folder or similar structure.');
    return;
  }
  const statements = splitSqlStatements(sqlCode);
  if (statements.length === 1 && containsMultipleSqlObjects(statements[0])) {
    vscode2.window.showWarningMessage(
      'The generated SQL contains multiple object definitions in a single block. Please ensure the LLM separates each object with a "GO" command for proper file splitting. You may need to manually split this file after applying changes.',
      "Understood"
    );
  }
  for (const stmt of statements) {
    const { type, name, action } = getSqlObjectNameTypeAndAction(stmt);
    console.log(`Processing statement: Action=${action}, Type=${type}, Name=${name}, StatementSnippet=${stmt.substring(0, 50)}...`);
    if (!type || !name || !action) {
      vscode2.window.showWarningMessage(`Could not determine object type, name, or action for SQL statement: ${stmt.substring(0, 50)}... Skipping.`);
      console.warn("Skipping statement due to unknown type/name/action.");
      continue;
    }
    const targetRelativePathInDbo = resolveSqlFilePath(type, name);
    if (!targetRelativePathInDbo) {
      continue;
    }
    const targetFileUri = vscode2.Uri.joinPath(sqlFilesBaseUri, targetRelativePathInDbo);
    console.log(`Target file URI: ${targetFileUri.fsPath}`);
    try {
      let fileExists = false;
      try {
        await vscode2.workspace.fs.stat(targetFileUri);
        fileExists = true;
        console.log(`File ${targetFileUri.fsPath} exists.`);
      } catch (e) {
        if (e.code === "FileNotFound") {
          console.log(`File ${targetFileUri.fsPath} does not exist.`);
        } else {
          console.warn(`Error checking file ${targetFileUri.fsPath}: ${e.message}`);
        }
      }
      if (action === "CREATE" || action === "CREATE OR ALTER") {
        if (fileExists) {
          const selection = await vscode2.window.showInformationMessage(
            `File for ${type} ${name} already exists. What do you want to do?`,
            "Overwrite",
            "Append",
            "Cancel"
          );
          if (selection === "Overwrite") {
            console.log(`Overwriting ${targetFileUri.fsPath} with new content.`);
            await vscode2.workspace.fs.writeFile(targetFileUri, new TextEncoder().encode(stmt.trim()));
            vscode2.window.showInformationMessage(`Overwrote existing ${type} ${name} at ${targetFileUri.fsPath.replace(sqlFilesBaseUri.fsPath, "")}.`);
          } else if (selection === "Append") {
            console.log(`Appending to ${targetFileUri.fsPath}.`);
            const existingContent = new TextDecoder().decode(await vscode2.workspace.fs.readFile(targetFileUri));
            await vscode2.workspace.fs.writeFile(targetFileUri, new TextEncoder().encode(existingContent.trim() + "\n\n" + stmt.trim()));
            vscode2.window.showInformationMessage(`Appended new ${type} ${name} to existing file ${targetFileUri.fsPath.replace(sqlFilesBaseUri.fsPath, "")}.`);
          } else {
            vscode2.window.showInformationMessage(`Action for ${type} ${name} cancelled.`);
            console.log(`Action for ${type} ${name} cancelled by user.`);
            continue;
          }
        } else {
          const dirUri = vscode2.Uri.file(path.dirname(targetFileUri.fsPath));
          console.log(`Creating directory ${dirUri.fsPath} for new file.`);
          await vscode2.workspace.fs.createDirectory(dirUri);
          console.log(`Writing new file ${targetFileUri.fsPath}.`);
          await vscode2.workspace.fs.writeFile(targetFileUri, new TextEncoder().encode(stmt.trim()));
          vscode2.window.showInformationMessage(`Created new file for ${type} ${name} at ${targetFileUri.fsPath.replace(sqlFilesBaseUri.fsPath, "")}.`);
        }
      } else if (action === "ALTER") {
        if (fileExists) {
          console.log(`Appending ALTER statement to existing file ${targetFileUri.fsPath}.`);
          const existingContent = new TextDecoder().decode(await vscode2.workspace.fs.readFile(targetFileUri));
          await vscode2.workspace.fs.writeFile(targetFileUri, new TextEncoder().encode(existingContent.trim() + "\n\n" + stmt.trim()));
          vscode2.window.showInformationMessage(`Appended ALTER statement for ${type} ${name} to ${targetFileUri.fsPath.replace(sqlFilesBaseUri.fsPath, "")}.`);
        } else {
          vscode2.window.showWarningMessage(`Cannot ALTER ${type} ${name}. File does not exist at ${targetFileUri.fsPath.replace(sqlFilesBaseUri.fsPath, "")}. Skipping.`);
          console.warn(`Cannot ALTER non-existent file: ${targetFileUri.fsPath}`);
        }
      } else if (action === "DROP") {
        if (fileExists) {
          const selection = await vscode2.window.showInformationMessage(
            `Are you sure you want to DELETE the file for ${type} ${name}? This action cannot be undone easily.`,
            "Yes, Delete",
            "No, Keep"
          );
          if (selection === "Yes, Delete") {
            console.log(`Deleting file ${targetFileUri.fsPath}.`);
            await vscode2.workspace.fs.delete(targetFileUri, { recursive: false, useTrash: true });
            vscode2.window.showInformationMessage(`Deleted file for ${type} ${name} from ${targetFileUri.fsPath.replace(sqlFilesBaseUri.fsPath, "")}.`);
          } else {
            vscode2.window.showInformationMessage(`Deletion of ${type} ${name} cancelled.`);
            console.log(`Deletion of ${type} ${name} cancelled by user.`);
          }
        } else {
          vscode2.window.showInformationMessage(`Cannot DROP ${type} ${name}. File does not exist at ${targetFileUri.fsPath.replace(sqlFilesBaseUri.fsPath, "")}. It might already be removed.`);
          console.log(`Cannot DROP non-existent file: ${targetFileUri.fsPath}`);
        }
      } else {
        vscode2.window.showWarningMessage(`Unsupported SQL action '${action}' for ${type} ${name}. Skipping statement.`);
        console.warn(`Unsupported action: ${action} for ${type} ${name}`);
      }
      if (action !== "DROP" || action === "DROP" && !fileExists) {
        try {
          const document = await vscode2.workspace.openTextDocument(targetFileUri);
          await vscode2.window.showTextDocument(document);
          console.log(`Opened file ${targetFileUri.fsPath} in editor.`);
        } catch (openError) {
          console.warn(`Could not open file ${targetFileUri.fsPath}: ${openError.message}`);
        }
      }
    } catch (writeError) {
      vscode2.window.showErrorMessage(`Failed to apply SQL change for ${type} ${name}: ${writeError.message}`);
      console.error(`Error writing to file ${targetFileUri.fsPath}:`, writeError);
    }
  }
  vscode2.window.showInformationMessage("SQL changes application complete. Please review affected files.");
}
function splitSqlStatements(sqlCode) {
  return sqlCode.split(/^\s*GO\s*$/gim).map((s) => s.trim()).filter((s) => s.length > 0);
}
function containsMultipleSqlObjects(sqlBlock) {
  const objectDefinitionKeywords = [
    "CREATE\\s+TABLE",
    "ALTER\\s+TABLE",
    "CREATE\\s+PROCEDURE",
    "ALTER\\s+PROCEDURE",
    "CREATE\\s+OR\\s+ALTER\\s+PROCEDURE",
    "CREATE\\s+VIEW",
    "ALTER\\s+VIEW",
    "CREATE\\s+OR\\s+ALTER\\s+VIEW",
    "CREATE\\s+FUNCTION",
    "ALTER\\s+FUNCTION",
    "CREATE\\s+OR\\s+ALTER\\s+FUNCTION",
    "DROP\\s+TABLE",
    "DROP\\s+PROCEDURE",
    "DROP\\s+VIEW",
    "DROP\\s+FUNCTION"
  ];
  const regex = new RegExp(objectDefinitionKeywords.join("|"), "gi");
  const matches = sqlBlock.match(regex);
  return matches ? matches.length > 1 : false;
}
function getSqlObjectNameTypeAndAction(sqlStatement) {
  let type = null;
  let name = null;
  let action = null;
  let match = sqlStatement.match(/^(CREATE|ALTER|DROP)\s+TABLE\s+\[?(\w+)\]?(?:\.\[?(\w+)\]?)?/i);
  if (match) {
    action = match[1].toUpperCase();
    type = "TABLE";
    name = match[3] || match[2];
    return { type, name, action };
  }
  match = sqlStatement.match(/^(CREATE\s+OR\s+ALTER|CREATE|ALTER|DROP)\s+PROCEDURE\s+\[?(\w+)\]?(?:\.\[?(\w+)\]?)?/i);
  if (match) {
    action = match[1].toUpperCase().replace(/\s+/g, " ");
    type = "STORED_PROCEDURE";
    name = match[3] || match[2];
    return { type, name, action };
  }
  match = sqlStatement.match(/^(CREATE|ALTER|DROP)\s+VIEW\s+\[?(\w+)\]?(?:\.\[?(\w+)\]?)?/i);
  if (match) {
    action = match[1].toUpperCase();
    type = "VIEW";
    name = match[3] || match[2];
    return { type, name, action };
  }
  match = sqlStatement.match(/^(CREATE|ALTER|DROP)\s+FUNCTION\s+\[?(\w+)\]?(?:\.\[?(\w+)\]?)?/i);
  if (match) {
    action = match[1].toUpperCase();
    type = "FUNCTION";
    name = match[3] || match[2];
    return { type, name, action };
  }
  if (sqlStatement.match(/^(INSERT|UPDATE|DELETE)\s+FROM/i)) {
    action = sqlStatement.match(/^(INSERT|UPDATE|DELETE)/i)[1].toUpperCase();
    type = "DML";
    name = "DML_Statement";
    return { type, name, action };
  }
  return { type: null, name: null, action: null };
}
function resolveSqlFilePath(objectType, objectName) {
  const fileName = `${objectName}.sql`;
  switch (objectType.toUpperCase()) {
    case "TABLE":
      return path.join("Tables", fileName);
    case "STORED_PROCEDURE":
      return path.join("Stored Procedures", fileName);
    case "VIEW":
      return path.join("Views", fileName);
    // Assuming a 'Views' folder
    case "FUNCTION":
      return path.join("Functions", fileName);
    // Assuming a 'Functions' folder
    case "DML":
      vscode2.window.showWarningMessage(`DML statements are not automatically saved to object-specific files. Please copy manually.`);
      return null;
    default:
      vscode2.window.showWarningMessage(`Unsupported SQL object type for file path resolution: ${objectType}`);
      return null;
  }
}
function getWebviewContent(webview, extensionUri) {
  const tailwindCssCdnUri = webview.asWebviewUri(vscode2.Uri.joinPath(extensionUri, "node_modules", "tailwindcss", "tailwind.min.js"));
  return `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SaralFlow SQL Generator</title>
        <!-- Load Tailwind CSS from CDN -->
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            body {
                font-family: 'Inter', sans-serif;
                background-color: #1e1e1e; /* VS Code dark background */
                color: #cccccc; /* VS Code foreground color */
            }
            textarea {
                background-color: #333333; /* Darker background for textareas */
                color: #cccccc;
                border: 1px solid #555555;
                border-radius: 8px; /* Rounded corners */
                padding: 12px;
                resize: vertical; /* Allow vertical resizing */
                font-family: monospace; /* Monospace for code */
            }
            button {
                background-color: #007acc; /* VS Code primary blue */
                color: white;
                padding: 10px 20px;
                border-radius: 8px;
                cursor: pointer;
                transition: background-color 0.2s;
                font-weight: bold;
            }
            button:hover {
                background-color: #005f99;
            }
            .button-group {
                display: flex;
                gap: 1rem; /* Space between buttons */
                justify-content: center;
                margin-top: 1.5rem;
            }
            .button-group button {
                flex-grow: 1; /* Allow buttons to grow */
                max-width: 200px; /* Limit max width */
            }
            /* Specific styling for the Generate SQL button */
            #generateButton {
                background-color: #007acc; /* VS Code primary blue */
                color: white;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow */
                border: none; /* Remove default border */
            }
            #generateButton:hover {
                background-color: #005f99;
                box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2); /* Slightly larger shadow on hover */
            }
        </style>
    </head>
    <body class="p-6">
        <div class="max-w-4xl mx-auto bg-gray-800 p-8 rounded-lg shadow-lg">
            <h1 class="text-2xl font-bold mb-6 text-center text-white">Story to TSQL Code Generation</h1>

            <div class="mb-6">
                <label for="scenarioInput" class="block text-gray-300 text-sm font-bold mb-2">
                    Story Description / Scenario:
                </label>
                <textarea id="scenarioInput" class="w-full h-32 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Describe what you want to do in a clear and concise way."></textarea>
            </div>

            <div class="button-group">
                <button id="generateButton">Generate SQL</button>
                <button id="acceptButton" class="bg-green-600 hover:bg-green-700">Accept Change</button>
            </div>

            <div class="mt-6">
                <label for="proposedCodeOutput" class="block text-gray-300 text-sm font-bold mb-2">
                    Proposed SQL Code:
                </label>
                <textarea id="proposedCodeOutput" class="w-full h-48 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Generated SQL code will appear here..." readonly></textarea>
            </div>
        </div>

        <script>
            const vscode = acquireVsCodeApi(); // VS Code API for webviews

            const scenarioInput = document.getElementById('scenarioInput');
            const generateButton = document.getElementById('generateButton');
            const acceptButton = document.getElementById('acceptButton'); // Get the new button
            const proposedCodeOutput = document.getElementById('proposedCodeOutput');

            generateButton.addEventListener('click', () => {
                const scenarioText = scenarioInput.value;
                if (scenarioText.trim()) {
                    vscode.postMessage({
                        command: 'generateSql',
                        text: scenarioText
                    });
                    proposedCodeOutput.value = 'Generating SQL...';
                } else {
                    proposedCodeOutput.value = 'Please enter a story description/scenario.';
                }
            });

            // Add event listener for the new Accept Change button
            acceptButton.addEventListener('click', () => {
                const sqlToApply = proposedCodeOutput.value;
                if (sqlToApply.trim() && sqlToApply !== 'Generating SQL...' && sqlToApply !== 'Error generating SQL...' && sqlToApply !== 'Changes not applied.' && sqlToApply !== 'Changes applied. Please review your files.') {
                    vscode.postMessage({
                        command: 'acceptChange',
                        text: sqlToApply
                    });
                } else {
                    vscode.window.showWarningMessage('No valid SQL code to apply.');
                }
            });

            // Handle messages from the extension
            window.addEventListener('message', event => {
                const message = event.data;
                switch (message.command) {
                    case 'displaySql':
                        proposedCodeOutput.value = message.text;
                        break;
                }
            });
        </script>
    </body>
    </html>`;
}
function deactivate() {
}
async function processDocumentSymbols(document, symbols, graph, parentNodeId) {
  for (const symbol of symbols) {
    const nodeId = generateNodeId(document.uri, symbol);
    let symbolRange;
    let symbolUri;
    if ("range" in symbol) {
      symbolRange = symbol.range;
      symbolUri = document.uri;
    } else {
      symbolRange = symbol.location.range;
      symbolUri = symbol.location.uri;
    }
    const nodeKind = toNodeKind(symbol.kind);
    graph.addNode({
      id: nodeId,
      label: symbol.name,
      kind: nodeKind,
      uri: symbolUri,
      // <-- Use the determined URI
      range: symbolRange,
      // <-- Use the determined range
      detail: "detail" in symbol ? symbol.detail : void 0
    });
    graph.addEdge({
      sourceId: parentNodeId,
      targetId: nodeId,
      type: "CONTAINS" /* CONTAINS */
    });
    if ("children" in symbol && symbol.children && symbol.children.length > 0) {
      await processDocumentSymbols(document, symbol.children, graph, nodeId);
    }
  }
}
async function fetchAndProcessCallHierarchy(document, node, graph) {
  try {
    const callHierarchyItems = await vscode2.commands.executeCommand(
      "vscode.executeCallHierarchyPrepare",
      node.uri,
      node.range.start
    );
    if (!callHierarchyItems || callHierarchyItems.length === 0) {
      return;
    }
    const callHierarchyItem = callHierarchyItems[0];
    const outgoingCalls = await vscode2.commands.executeCommand(
      "vscode.executeCallHierarchyOutgoingCalls",
      callHierarchyItem
    );
    for (const outgoingCall of outgoingCalls) {
      const targetNodeId = generateNodeId(outgoingCall.to.uri, outgoingCall.to);
      graph.addNode({
        id: targetNodeId,
        label: outgoingCall.to.name,
        kind: toNodeKind(outgoingCall.to.kind),
        uri: outgoingCall.to.uri,
        range: outgoingCall.to.range,
        detail: outgoingCall.to.detail
      });
      graph.addEdge({
        sourceId: node.id,
        targetId: targetNodeId,
        type: "CALLS" /* CALLS */
      });
    }
    const incomingCalls = await vscode2.commands.executeCommand(
      "vscode.executeCallHierarchyIncomingCalls",
      callHierarchyItem
    );
    for (const incomingCall of incomingCalls) {
      const sourceNodeId = generateNodeId(incomingCall.from.uri, incomingCall.from);
      graph.addNode({
        id: sourceNodeId,
        label: incomingCall.from.name,
        kind: toNodeKind(incomingCall.from.kind),
        uri: incomingCall.from.uri,
        range: incomingCall.from.range,
        detail: incomingCall.from.detail
      });
      graph.addEdge({
        sourceId: sourceNodeId,
        targetId: node.id,
        type: "CALLED_BY" /* CALLED_BY */
      });
    }
  } catch (error) {
    console.warn(`Could not fetch call hierarchy for ${node.label}:`, error);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
//# sourceMappingURL=extension.js.map
