// src/graphTypes.ts

import * as vscode from 'vscode';

/**
 * Represents a node in our semantic code graph.
 */
export interface GraphNode {
    id: string; // A unique identifier for the node (e.g., 'file:///path/to/file.ts#MyClass', 'file:///path/to/file.ts#myFunction')
    label: string; // Display name for the node (e.g., 'MyClass', 'myFunction')
    kind: NodeKind; // Type of symbol (e.g., File, Class, Function, Variable)
    uri: vscode.Uri; // The URI of the file where this symbol is defined
    range: vscode.Range; // The range in the file where this symbol is defined
    detail?: string; // Optional: additional details (e.g., function signature, variable type)
    // You can add more properties as needed, like:
    // parentId?: string; // For hierarchical relationships (e.g., method within a class)
    // childrenIds?: string[]; // For hierarchical children
}

/**
 * Defines the types of nodes we can have in our graph.
 * Mapped to VS Code's SymbolKind for consistency.
 */
export enum NodeKind {
    File = 0,
    Module = 1,
    Namespace = 2,
    Package = 3,
    Class = 4,
    Method = 5,
    Property = 6,
    Field = 7,
    Constructor = 8,
    Enum = 9,
    Interface = 10,
    Function = 11,
    Variable = 12,
    Constant = 13,
    String = 14,
    Number = 15,
    Boolean = 16,
    Array = 17,
    Object = 18,
    Key = 19,
    Null = 20,
    EnumMember = 21,
    Struct = 22,
    Event = 23,
    Operator = 24,
    TypeParameter = 25,
    // Custom kinds not directly from SymbolKind
    Import = 1000, // For import statements
    Reference = 1001, // For generic references
    // Add more as your semantic graph grows
}

/**
 * Represents an edge (relationship) in our semantic code graph.
 */
export interface GraphEdge {
    id: string; // Unique ID for the edge (e.g., 'nodeA_CALLS_nodeB')
    sourceId: string; // ID of the source node
    targetId: string; // ID of the target node
    type: EdgeType; // Type of relationship (e.g., CALLS, REFERENCES, DEFINES)
    // Optional: context where the edge was found (e.g., `vscode.Location` from a reference)
    // location?: vscode.Location;
}

/**
 * Defines the types of relationships (edges) we can have.
 */
export enum EdgeType {
    CALLS = 'CALLS',
    CALLED_BY = 'CALLED_BY',
    REFERENCES = 'REFERENCES', // A symbol refers to another symbol
    DEFINES = 'DEFINES', // A container defines a member (e.g., Class defines Method)
    HAS_TYPE = 'HAS_TYPE', // A variable has a certain type
    IMPORTS = 'IMPORTS', // A file/module imports another module
    EXTENDS = 'EXTENDS', // A class extends another class
    IMPLEMENTS = 'IMPLEMENTS', // A class implements an interface
    CONTAINS = 'CONTAINS', // A file contains a class, a class contains a method etc. (hierarchical)
    // Add more as your semantic graph grows
}

/**
 * The main class to hold and manage our graph data.
 */
export class CodeGraph {
    nodes: Map<string, GraphNode> = new Map();
    edges: Map<string, GraphEdge> = new Map();

    addNode(node: GraphNode): void {
        if (!this.nodes.has(node.id)) {
            this.nodes.set(node.id, node);
            // console.log(`Added node: ${node.id} (${node.kind})`);
        }
    }

    /**
     * Represents the data needed to create a new edge, excluding the 'id'
     * which is generated by the CodeGraph.
     */
    public addEdge(edgePayload: Omit<GraphEdge, 'id'>): void { // <--- CHANGE HERE: Use Omit<GraphEdge, 'id'>
        const edgeId = `${edgePayload.sourceId}_${edgePayload.type}_${edgePayload.targetId}`; // Generate unique ID
        if (!this.edges.has(edgeId)) {
            this.edges.set(edgeId, { ...edgePayload, id: edgeId }); // Create the full GraphEdge and set it
        }
    }

    // You can add more methods here for querying the graph
    getNode(id: string): GraphNode | undefined {
        return this.nodes.get(id);
    }

    getEdges(): GraphEdge[] {
        return Array.from(this.edges.values());
    }

    getNodes(): GraphNode[] {
        return Array.from(this.nodes.values());
    }

    clear(): void {
        this.nodes.clear();
        this.edges.clear();
    }
}
/**
 * A minimal interface for symbol-like objects that only contain 'name' and 'kind'.
 * This is used for `generateNodeId` to avoid strict type mismatches with full VS Code symbol types.
 */
export interface SimpleSymbolInfo { // <-- NEW INTERFACE
    name: string;
    kind: vscode.SymbolKind;
}

/**
 * Helper to generate a unique ID for a symbol node.
 * Uses URI, symbol name, and kind to make it relatively unique.
 * NOW ACCEPTS SimpleSymbolInfo.
 */
export function generateNodeId(uri: vscode.Uri, symbol: SimpleSymbolInfo): string { // <-- UPDATED PARAMETER TYPE
    return `${uri.toString()}#${symbol.kind}_${symbol.name}`;
}

/**
 * Helper to convert VS Code SymbolKind to our NodeKind.
 */
export function toNodeKind(symbolKind: vscode.SymbolKind): NodeKind {
    if (symbolKind >= vscode.SymbolKind.File && symbolKind <= vscode.SymbolKind.TypeParameter) {
        return symbolKind as unknown as NodeKind;
    }
    return NodeKind.Reference;
}